<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
</head>
<body>
<script>
/**
 * @param {number[]} nums
 * @return {number}
 */
// 给定一个无序的数组，找出数组在排序之后，相邻元素之间最大的差值。
//
// 如果数组元素个数小于 2，则返回 0。

// 你可以假设数组中所有元素都是非负整数，且数值在 32 位有符号整数范围内。
// 请尝试在线性时间复杂度和空间复杂度的条件下解决此问题。

// 看了答案  桶排序
// 排序后每个相邻数据的差值的最大值 一定大于 (max - min) / N - 1; 所以可以吧这个长度作为每个桶的长度。
var maximumGap = function(nums) {
  const len = nums.length;
  if (len < 2) return 0;
  const maxNum = Math.max(...nums);
  const minNum = Math.min(...nums);
  const bucketLen = Math.max(1, Math.floor((maxNum - minNum) / (len - 1)));
  const bucketCount = Math.floor((maxNum - minNum) / bucketLen) + 1;
  const buckets = new Array(bucketCount).fill(0).map(item => new Array(2).fill(-1));

  for (let i = 0; i < len; i++) {
    let position = Math.floor((nums[i] - minNum) / bucketLen);
    if (buckets[position][0] === -1) {
      buckets[position][0] = buckets[position][1] = nums[i];
    } else {
      buckets[position][0] = Math.min(buckets[position][0], nums[i]);
      buckets[position][1] = Math.max(buckets[position][1], nums[i]);
    }
  }
  let max = 0;
  let prev = 0;
  for (let i = 1; i < bucketCount; i++) {
    if (buckets[i][0] !== -1) {
      max = Math.max(buckets[i][0] - buckets[prev][1], max);
      prev = i;
    }
  }
  return max;
};
let test = [15252,16764,27963,7817,26155,20757,3478,22602,20404,6739,16790,10588,16521,6644,20880,15632,27078,25463,20124,15728,30042,16604,17223,4388,23646,32683,23688,12439,30630,3895,7926,22101,32406,21540,31799,3768,26679,21799,23740];
console.log(maximumGap(test));
</script>
</body>
</html>
