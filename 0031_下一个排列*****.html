<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script>

     /**
     * @param {number[]} nums
     * @return {void} Do not return anything, modify nums in-place instead.
     */
     // var nextPermutation = function(nums) {
     //     const len = nums.length;
     //     if (len < 2) {
     //         return nums;
     //     }
     //     let i = len - 1;
     //     let j = len - 1;
     //     for(; i > 0; i--) {
     //         if (nums[i] > nums[i - 1]) {
     //             for (; j > 0; j--) {
     //                 if(nums[j] > nums[i - 1]) {
     //                     let temp = nums[j];
     //                     nums[j] = nums[i - 1];
     //                     nums[i - 1] = temp;
     //                     break;
     //                 }
     //             }
     //             break;
     //         }
     //     }
     //     // flag = 0说明目前已经是最大的排列的  需要换成最小的排列!
     //     if (i === 0) {
     //         return nums.reverse();
     //     }
     //     let p = i;
     //     console.log(JSON.parse(JSON.stringify(nums)));
     //     // 翻转 索引 i - 1 之后的数组
     //     for (let i = p ; i < p + Math.floor((len - p) / 2); i++) {
     //         let temp = nums[i];
     //         nums[i] = nums[len - i - 1 + p];
     //         nums[len - i - 1 + p] = temp;
     //     }
     //     return nums;
     // };
     // console.log(nextPermutation([1,3,2]));
     // // console.log(nextPermutation([1,2,7,4,3,1]));

//     第二次尝试
// 分析：
// 1、从后往前遍历 如果后面的数大于前面的;
// 2、i === 0 不存在更大的排列 则目前一定是倒叙。
//****** 看答案才想到的，换位以后， i之后的序列一定是逆序的 所以再反转一次就好
//****** 可以简化O(n2)的时间复杂度（我比你小，你比他小，那我肯定比他小）

var nextPermutation = function(nums) {
  const len = nums.length;
  let i = len - 1,
    j = len - 1;
  for( ; i > 0; i--) {
    if (nums[i] > [nums[i - 1]]) {
      for ( ; j > 0; j--) {
        if (nums[j] > nums[i - 1]) {
          [nums[j], nums[i - 1]] = [nums[i - 1], nums[j]];
          break;
        }
      }
      break;
    }
  }
  // i = 0 说明完全逆序
  if (i === 0) {
    for (let i = 0; i < len / 2; i++) {
      [nums[i], nums[len - i - 1]] = [nums[len - i - 1], nums[i]];
    }
    return nums;
  }
  // 反转 i - 1后面的
    for (let k = i; k < (len + i) / 2; k++) {
    [nums[k], nums[len + i - k - 1]] = [nums[len + i - k - 1], nums[k]]
  }
  return nums;
  };
let test = [9, 1, 7, 6, 5];
     console.log(nextPermutation(test));
</script>
</body>
</html>
