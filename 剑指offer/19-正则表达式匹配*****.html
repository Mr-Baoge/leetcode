<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
</head>
<body>
<script>
// 主串A 长度为 i  模式串B 长度为 j
// f[i][j] 代表 A的前i个与B的前j个是否匹配
// B的最后一个字符有三种情况
// 1 B[j - 1] = 普通字符 所以只需要比较A的最后一个字符和这个字符是否相等(A[i - 1] === B[j - 1]) 相等的话 状态就转移给了 f[i - 1][j - 1]。 不相等的话 就是false;
// 2  B[j - 1] = "." 因为"."会匹配任意字符  状态就转移给 f[i - 1][j - 1];
// 3  B[j - 1] = "*" 这种情况复杂一些 需要看B[j - 2] 是否等于 A[i - 1]; 不等的话B的这两个字符就废了 状态转移给了 f[i][j - 2]
// **** 3 相等的话 重点到了！！  把A[i - 1]这个字符扔掉，继续用B[i - 1]* 这两个字符向前匹配 也就是状态转移给f[i - 1][j];
// 综上 状态转移方程为:
// f[i][j] = {
//  if (B[j - 1) !== '*' {
//    if (A[i - 1] === B[j - 1] ||  B[j - 1] = ".")   f[i - 1][j - 1]
//  } else {
//    if (B[j - 2] === A[i - 1]) f[i - 1][j];
//    else f[i][j - 2];
//  }
// }

/**
 * @param {string} s
 * @param {string} p
 * @return {boolean}
 */
var isMatch = function(s, p) {

  const m = s.length;
  const n = p.length;

  let f = new Array(m + 1).fill(1).map(() => new Array(n + 1).fill(false));
  f[0][0] = true;
  for (let i = 0; i <= m; ++i) {
    for (let j = 1; j <= n; ++j) {
      if (p[j - 1] === '*') {
        f[i][j] = f[i][j - 2];
        // f[i][j] = check(i, j - 1) ? f[i][j] || f[i - 1][j] :f[i][j] ||  f[i][j - 2];
        if (check(i, j - 1)) {
          f[i][j] = f[i][j] || f[i - 1][j]
        }
      } else {
        if (check(i ,j)) {
          f[i][j] =f[i][j] || f[i - 1][j - 1]
        }
      }
    }
  }

  function check(i, j) {
    if (i === 0) {
      return false;
    }
    if (p[j - 1] === '.') {
      return true;
    }
    return p[j - 1] === s[i - 1] ;
  }
  return f[m][n];
};
console.log(isMatch('abcd', 'a*b*c*d*'));
</script>
</body>
</html>
