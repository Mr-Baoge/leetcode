<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script>
//     在给定的网格中，每个单元格可以有以下三个值之一：
//
// 值 0 代表空单元格；
// 值 1 代表新鲜橘子；
// 值 2 代表腐烂的橘子。
// 每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。
//
// 返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1。
/**
 * @param {number[][]} grid
 * @return {number}
 */
let test = [
    [2,1,1],[0,1,1],[1,0,1]
];
var orangesRotting = function(grid) {
    function diffusion({i, j}) {
        let nextTick = [];
        console.log(i, j);
        if(grid[i + 1] && grid[i + 1][j] === 1){
                count--;
                grid[i + 1][j] = 2;
                nextTick.push({i: i + 1, j: j})
            }if(grid[i - 1] && grid[i - 1][j] === 1){
                count--;
                grid[i - 1][j] = 2;
                nextTick.push({i: i - 1, j: j})
            }if(grid[i] && grid[i][j + 1] === 1){
                count--;
                grid[i][j + 1] = 2;
                nextTick.push({i: i, j: j + 1})
            }if(grid[i] && grid[i][j - 1] === 1){
                count--;
                grid[i][j - 1] = 2;
                nextTick.push({i: i, j: j - 1})
            }
        console.log(count);
        return nextTick;
        // grid[i, j] = 3;
    }
    // 初始化 1个数  和初轮的nextTick
    let count = 0;
    let nextTick = [];
    let minute = 0;
    for(let i = 0; i < grid.length; i++) {
        for(let j = 0; j < grid[0].length; j++) {
            if (grid[i][j] === 1) {
                count++;
            }
            if (grid[i][j] === 2) {
                nextTick.push({i, j})
            }
        }
    }
    console.log('1的总数count:', count);
    while(count) {
        if (!nextTick.length) {
            return -1;
        }
        minute++;
        let temp = [];
        nextTick.forEach(item => {
            temp = [...temp, ...diffusion(item)];
            console.log(nextTick);
        });
        nextTick = temp;
    }
    return minute;
};
console.log(orangesRotting(test));
</script>
</body>
</html>
